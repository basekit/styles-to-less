(function() {
  var CSSLint, LessCachedFile, LessFile, LintCache, Parser, async, chalk, crypto, defaultLessOptions, findLessMapping, findPropertyLineNumber, getPropertyName, path, stripPath, _, _ref, _ref1;

  CSSLint = require('csslint').CSSLint;

  Parser = require('less').Parser;

  _ref = require('./lib/lint-utils'), findLessMapping = _ref.findLessMapping, findPropertyLineNumber = _ref.findPropertyLineNumber, getPropertyName = _ref.getPropertyName;

  LintCache = require('./lib/lint-cache').LintCache;

  _ref1 = require('./lib/less-file'), LessFile = _ref1.LessFile, LessCachedFile = _ref1.LessCachedFile;

  async = require('async');

  path = require('path');

  crypto = require('crypto');

  stripPath = require('strip-path');

  _ = require('underscore');

  chalk = require('chalk');

  defaultLessOptions = {
    cleancss: false,
    compress: false,
    dumpLineNumbers: 'comments',
    optimization: null,
    syncImport: true
  };

  module.exports = function(grunt) {
    var isFileError, originalPositionFor, processLintErrors, writeToFormatters;
    originalPositionFor = function(css, less, file, line) {
      var cssLines, cssPropertyName, filePath, lessLines, lineNumber, propertyNameLineNumber, _ref2;
      cssLines = css.split('\n');
      if (!((0 <= line && line < cssLines.length))) {
        return {
          lineNumber: -1
        };
      }
      _ref2 = findLessMapping(cssLines, line), lineNumber = _ref2.lineNumber, filePath = _ref2.filePath;
      if (filePath !== path.resolve(process.cwd(), file)) {
        less = grunt.file.read(filePath);
      }
      lessLines = less.split('\n');
      if ((0 <= lineNumber && lineNumber < lessLines.length)) {
        if (cssPropertyName = getPropertyName(cssLines[line])) {
          propertyNameLineNumber = findPropertyLineNumber(lessLines, lineNumber, cssPropertyName);
          if (propertyNameLineNumber >= 0) {
            lineNumber = propertyNameLineNumber;
          }
        }
      }
      if ((0 <= lineNumber && lineNumber < lessLines.length)) {
        return {
          lineNumber: lineNumber,
          filePath: filePath,
          less: less
        };
      } else {
        return {
          lineNumber: -1,
          filePath: filePath,
          less: less
        };
      }
    };
    isFileError = function(file, css, line, importsToLint) {
      var filePath;
      filePath = findLessMapping(css, line).filePath;
      return filePath === path.resolve(process.cwd(), file) || ((filePath != null) && grunt.file.isMatch(importsToLint, stripPath(filePath, process.cwd())));
    };
    writeToFormatters = function(options, results) {
      var formatters;
      formatters = options.formatters;
      if (!_.isArray(formatters)) {
        return;
      }
      return formatters.forEach(function(_arg) {
        var dest, filePath, formatter, formatterOutput, id, result;
        id = _arg.id, dest = _arg.dest;
        if (!(id && dest)) {
          return;
        }
        formatter = CSSLint.getFormatter(id);
        if (formatter == null) {
          return;
        }
        formatterOutput = formatter.startFormat();
        for (filePath in results) {
          result = results[filePath];
          formatterOutput += formatter.formatResults(result, filePath, {});
        }
        formatterOutput += formatter.endFormat();
        return grunt.file.write(dest, formatterOutput);
      });
    };
    processLintErrors = function(file, importsToLint, result, less, css) {
      var cssLine, errorPrefix, fileErrors, filePath, fullRuleMessage, line, lineNumber, message, messages, rule, ruleMessage, ruleMessages, _i, _len, _ref2, _ref3;
      messages = (_ref2 = result.messages) != null ? _ref2 : [];
      messages = messages.filter(function(message) {
        return isFileError(file, css, message.line - 1, importsToLint);
      });
      fileErrors = 0;
      grunt.log.writeln("" + (chalk.yellow(file)) + " (" + messages.length + ")");
      messages = _.groupBy(messages, function(_arg) {
        var message;
        message = _arg.message;
        return message;
      });
      for (ruleMessage in messages) {
        ruleMessages = messages[ruleMessage];
        rule = ruleMessages[0].rule;
        fullRuleMessage = "" + ruleMessage + " ";
        if (rule.desc && rule.desc !== ruleMessage) {
          fullRuleMessage += "" + rule.desc + " ";
        }
        grunt.log.writeln(fullRuleMessage + chalk.grey("(" + rule.id + ")"));
        for (_i = 0, _len = ruleMessages.length; _i < _len; _i++) {
          message = ruleMessages[_i];
          line = message.line;
          line--;
          fileErrors++;
          if (line < 0) {
            continue;
          }
          _ref3 = originalPositionFor(css, less, file, line), lineNumber = _ref3.lineNumber, filePath = _ref3.filePath, less = _ref3.less;
          if (lineNumber >= 0) {
            message.line = lineNumber;
            errorPrefix = chalk.yellow("" + (stripPath(filePath, process.cwd())) + " " + (lineNumber + 1) + ":");
            grunt.log.error("" + errorPrefix + " " + (less.split('\n')[lineNumber].trim()));
          } else {
            cssLine = css.split('\n')[line];
            if (cssLine != null) {
              errorPrefix = chalk.yellow("" + (line + 1) + ":");
              grunt.log.error("" + errorPrefix + " " + (cssLine.trim()));
            }
            grunt.log.writeln(chalk.yellow("Failed to find map CSS line " + (line + 1) + " to a LESS line."));
          }
        }
      }
      return fileErrors;
    };
    grunt.registerMultiTask('lesslint', 'Validate LESS files with CSS Lint', function() {
      var done, errorCount, fileCount, options, queue, results;
      options = this.options({
        less: grunt.config.get('less.options'),
        csslint: grunt.config.get('csslint.options'),
        imports: [],
        cache: false
      });
      fileCount = 0;
      errorCount = 0;
      results = {};
      queue = async.queue(function(file, callback) {
        var lessFile;
        grunt.verbose.write("Linting '" + file + "'");
        fileCount++;
        if (!options.cache) {
          lessFile = new LessFile(file, options, grunt);
        } else {
          lessFile = new LessCachedFile(file, options, grunt);
        }
        return lessFile.lint(function(err, lintResult, less, css) {
          var fileLintErrors;
          if (err != null) {
            errorCount++;
            grunt.log.writeln(err.message);
            return callback();
          }
          if (lintResult) {
            results[file] = lintResult;
            fileLintErrors = processLintErrors(file, options.imports, lintResult, less, css);
            errorCount += fileLintErrors;
          }
          return callback();
        });
      });
      this.filesSrc.forEach(function(file) {
        return queue.push(file);
      });
      done = this.async();
      return queue.drain = function() {
        writeToFormatters(options, results);
        if (errorCount === 0) {
          grunt.log.ok("" + fileCount + " " + (grunt.util.pluralize(fileCount, 'file/files')) + " lint free.");
          return done();
        } else {
          grunt.log.writeln();
          grunt.log.error("" + errorCount + " lint " + (grunt.util.pluralize(errorCount, 'error/errors')) + " in " + fileCount + " " + (grunt.util.pluralize(fileCount, 'file/files')) + ".");
          return done(false);
        }
      };
    });
    return grunt.registerTask('lesslint:clearCache', function() {
      var cache, done;
      done = this.async();
      cache = new LintCache();
      return cache.clear(function(err) {
        if (err) {
          grunt.log.error(err.message);
        }
        return done();
      });
    });
  };

}).call(this);
